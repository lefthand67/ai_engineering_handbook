# Git-сценарий: Случайно удалил нужные файлы 

---  

Владелец: Вадим Рудаков, lefthand67@gmail.com  
Версия: 0.1.1

---

Предположим, что пользователь работает в ветке, где некоторые важные файлы (например, `src/app.js` и `docs/readme.md`) внезапно исчезли — эти файлы отсутствуют в рабочем каталоге и в текущем коммите. Однако эти файлы существовали в предыдущих коммитах, и пользователь хочет восстановить их в том виде, в каком они были до удаления.  

При этом у пользователя есть незакоммиченные изменения, которые **нельзя потерять или перезаписать**. После восстановления удалённых файлов удалённая ветка должна оставаться согласованной с локальной.

## Важный предварительный совет: Сохраните незакоммиченные изменения  

Перед выполнением операций восстановления настоятельно рекомендуется сохранить незакоммиченные изменения, особенно если восстанавливаемые файлы могут конфликтовать с текущими правками:

```bash
git stash push -m "Save work before recovering deleted files"
```

Это временно сохранит изменения без коммита. После успешного восстановления и проверки можно вернуть их обратно:

```bash
git stash pop
```

Это гарантирует, что незакоммиченные изменения не будут потеряны в процессе восстановления.

## Случай 1. Структура репозитория не изменялась  

Вы точно знаете, где должны находиться ваши файлы, и их пути не изменились.

### Шаг 1: Найти последний коммит, содержащий удалённые файлы  
Используйте команду, чтобы найти коммиты, где эти файлы существовали:

```bash
git rev-list HEAD -- path/to/file
```

Пример для `src/app.js`:

```bash
git rev-list HEAD -- src/app.js
fba4e73c14da1383eda455205c0a82957bd68a13
cf0784c2018a7785846903ded27fd3a7ac253bfd
51d46b7c994311d23b6e8fd62ea5b5c1099951ca
e051976abf60fe383d0707837eae7348c29894bd
8991ac7a3f4f41e2b5c512662c831999d291ffd1
```

Список всех коммитов с этим файлом, начиная с самых новых. Также для более информативного вывода можно использовать:

```bash
git log -- path/to/file
```

### Шаг 2: Выберите коммит перед удалением файла  

Файл обычно удаляется в самом новом коммите, где его уже нет, поэтому выбирайте коммит непосредственно **до** этого.

> Совет: Для поиска коммита можно также использовать графический инструмент `gitk`:  
> ```  
> sudo apt install gitk       # Debian/Ubuntu  
> sudo dnf install git-gui    # Fedora  
> ```

### Шаг 3: Восстановите отсутствующие файлы из выбранного коммита без потери текущей работы  

Используйте команду `git restore` для восстановления конкретных файлов из выбранного коммита в рабочую директорию и индекс, не затрагивая другие незакоммиченные изменения:

```bash
git restore --source <commit_hash> --worktree --staged path/to/file
```

Пример для `src/app.js`:

```bash
git restore --source abc1234 --worktree --staged src/app.js
```

Если хотите восстановить файл только в рабочую директорию без автоматической индексации, опустите `--staged`.

### Шаг 4: Проверьте восстановленные файлы и сохранность текущих изменений  

```bash
git status
```

### Шаг 5: Зафиксируйте восстановленные файлы  

```bash
git commit -m "Restore deleted file src/app.js from previous commit"
```

Повторите для каждого отсутствующего файла или восстановите целую папку, если пропало много файлов.

### Шаг 6: Отправьте изменения в удалённый репозиторий  

```bash
git push origin <branch_name>
```

***

## Пример — Случай 1  

```bash
git rev-list HEAD -- src/app.js                 # Найти коммиты с файлом
# Предположим abc1234 — последний коммит с файлом
git restore --source abc1234 --worktree --staged src/app.js    # Восстановить файл
git status                                    # Проверить восстановление и текущие изменения
git commit -m "Восстановлен удалённый src/app.js"    # Зафиксировать
git push origin <branch_name>                  # Отправить в удалённый репозиторий
```

Этот способ безопасно восстанавливает удалённые файлы из истории без перезаписи текущих изменений и без повреждения истории коммитов.

## Случай 2: Структура репозитория значительно изменилась  

Если структура каталогов изменилась с момента последнего коммита, где файлы были, пути к файлам могли измениться.

### Проблема  

- Файлы находятся по другим путям в старом коммите.  
- Запуск `git restore` или `git checkout` с устаревшим путем может завершиться ошибкой или повредить текущие файлы.  
- Нужно вручную извлечь содержимое файлов из старого коммита и вручную переместить их в новые места.

### Шаг 1: Найти последний коммит со старыми путями  

```bash
git rev-list HEAD -- old/path/to/file.js
```

Предположим, коммит называется `abc1234`.

### Шаг 2: Вручную извлечь содержимое файла и сохранить по новому пути  

```bash
git show <commit_hash>:<old/path/to/file> > <new/path/to/file>
```

Пример:

```bash
git show abc1234:old/path/to/file.js > new/path/to/file.js
```

**Важно:** Эта команда перезапишет `new/path/to/file.js`, если он существует! Перед этим убедитесь, что текущие несохранённые изменения сохранены или заархивированы.

### Шаг 3: Добавьте и зафиксируйте восстановленный файл  

```bash
git add new/path/to/file.js
git commit -m "Восстановлен file.js из старого коммита с обновленным путем"
```

### Шаг 4: Убедитесь, что текущие изменения не затронуты  

```bash
git status
```

### Шаг 5: Отправьте изменения на удалённый сервер  

```bash
git push origin <branch_name>
```

### Дополнительно  

- Повторите шаг с `git show > new/path` для каждого файла.  
- Такой подход исключает удаление других файлов и даёт полный контроль.  
- Не используйте `git restore` или `git checkout`, если пути изменились.

### Пример — Случай 2  

```bash
git rev-list HEAD -- src/utils/helpers.js
# Предположим abc1234 — последний коммит с этим путем
git show abc1234:src/utils/helpers.js > lib/helpers.js
git add lib/helpers.js
git commit -m "Восстановлен helpers.js из старого коммита с новой структурой"
git push origin <branch_name>
```

## Случай 3: Восстановление целой директории с изменённой структурой  

Необходимо восстановить всю директорию из старого коммита, но путь сильно изменился.

### Шаг 1: Создайте временную ветку на старом коммите  

```bash
git switch -c tmp <old_commit_hash>
```

### Шаг 2: Скопируйте директорию во временное место в рабочем дереве  

```bash
cp -r <old_directory_path> tmp_<new_dir_name>
```

Пример:

```bash
cp -r old/src/utils tmp_utils
```

### Шаг 3: Быстро переключитесь обратно в рабочую ветку (коммит не нужен)  

```bash
git switch -
```

### Шаг 4: Переместите или переименуйте директорию в нужное место  

Пример:

```bash
mv tmp_utils lib/helpers
```

Или скопируйте файлы вручную из `tmp_utils` в нужные директории.

### Шаг 5: Индексируйте и зафиксируйте восстановленную директорию  

```bash
git add lib/helpers
git commit -m "Восстановлена директория utils из старого коммита по новому пути lib/helpers"
```

### Шаг 6: Отправьте изменения на удалённый репозиторий  

```bash
git push origin <your_branch>
```

***

### Шаг 7: Удалите временную ветку  

```bash
git branch -D tmp
```

## Почему этот способ хорош  
- Избегаете промежуточных коммитов в временной ветке.  
- Копирование сохраняется в рабочем дереве после переключения веток.  
- Позволяет гибко разместить восстановленную директорию.  
- Не нарушает текущую работу и историю Git.

### Пример — Случай 3  

```bash
git switch -c tmp abc1234
cp -r old/src/utils tmp_utils
git switch -
mv tmp_utils lib/helpers
git add lib/helpers
git commit -m "Восстановлена директория utils из коммита abc1234"
git push origin feature-branch
git branch -D tmp
```

# Заключение  

- Всегда предварительно сохраняйте незакоммиченные изменения с помощью `git stash`.  
- Для масштабных восстановлений используйте графические клиенты Git или специализированные утилиты.  
- Описанные методы ориентированы на безопасность, понятность и неразрушающие операции — идеально подходят для живой разработки с незакоммиченными изменениями.
