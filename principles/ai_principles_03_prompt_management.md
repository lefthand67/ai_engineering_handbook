# Основные принципы разработки с LLM для внутренних команд

> Владелец: Вадим Рудаков, lefthand67@gmail.com

Cоздание рабочей системы на базе LLM — это не просто написание промптов и соединение с внешними компонентами. Следует ясно отделять “технократические поделки” от продуктовой инженерии. Нижеизложенные принципы нацелены на то, чтобы помочь инженеру выстроить жизнеспособную систему, соответствующую промышленным стандартам разработки и эксплуатации.

# 3. Принципы управления промптами при разработке с LLM

Промпт ≠ код, но это артефакт разработки, который тоже должен иметь стандарты, версионироваться, тестироваться и автоматизироваться.

> Для подробных рекомендаций по реализации, включая примеры форматов файлов, определения схем, интеграцию с CI/CD и шаблоны тестирования см. специализированные руководства в разделе `/handbooks/context_engineering/`.
    
## 3.1 Промпты как полноценные артефакты разработки  
Рассматривайте все промпты, шаблоны и связанные метаданные как **структурированные конфигурационные файлы**, а не как разрозненный текст или встроенный в код контент:

- Храните эти файлы в **системах управления версиями** (Git) для точного отслеживания изменений, поддержки совместной работы и обеспечения воспроизводимости с течением времени.  
- Обязательно ведите **версионирование**: каждому промпту, шаблону присваивать семантические номера версий (semantic versioning — major.minor.patch), чтобы чётко сообщать характер изменений (ломающие, добавочные или исправления).  
- Избегайте молчаливого редактирования на месте; при значимых изменениях публикуйте новые версии для сохранения воспроизводимости и трассируемости.

> **Предупреждение:** Хранение промптов в виде разбросанных строк или страниц вики приводит к потере аудита и делает невозможным воспроизведение результатов моделей, после их внедрения в продакшен.

## 3.2 Внешний слой промпта
Все промпты, шаблоны, метаданные хранятся в формате JSON или YAML.
- Это облегчает версионирование, автоматическую обработку, интеграцию с CI/CD и совместную работу через Git.
- Формат легко читается и поддерживается всеми инструментами разработки.

### Пример YAML

```yaml
id: summarizer_v1.1.0
description: Generic summarizer prompt
template: |
  <instruction>Summarize the following text:</instruction>
  <content>{text}</content>
parameters:
  max_tokens: 512
  temperature: 0.3
```

### Пример JSON

```json
{
  "id": "summarizer_v1.1.0",
  "description": "Промпт для модели-суммаризатора",
  "template": "<instruction>Сделайте краткое резюме:</instruction>\n<content>{text}</content>",
  "parameters": {
    "max_tokens": 512,
    "temperature": 0.3
  }
}
```

## 3.3 Структурированное семантическое форматирование внутреннего слоя промптов  

Внутри текстового шаблона промптов используйте чёткую семантическую структуру для разграничения инструкций, ролей, контекста и вводимых данных

- Общий размер контекста не должен превышать ограничения модели (обычно 4k-8k токенов).  
- Для коротких промптов (до 4k токенов) предпочтителен Markdown с богатой семантикой и форматированием.  
- Для более сложных и больших промптов — применять XML-like разметку внутри текстовых блоков, хранящихся в JSON/YAML.
    - Такая разметка помогает моделям однозначно понимать разные блоки, роли и этапы, повышает стабильность ответов и поддерживает сложные мультиагентные сценарии.
    - Используйте теги 
        - `<instruction>`, 
        - `<context>`, 
        - `<system>`,
        - `<user>`, 
        - `<agent>`, 
        - `<thought>` и т.п.,
    - структура помогает модели однозначно идентифицировать роли и этапы в запросе,
    - снижает ошибочную интерпретацию и помогает мультиагентным системам корректно взаимодействовать.
- Разделение статических и динамических частей промпта на: 
    - **статические системные инструкции** (`<system>`) и 
    - **динамические пользовательские данные** (`<user>`).
    - Такое разделение облегчает адаптацию, способствует повторному использованию и проясняет намерения в сложных диалогах и API-вызовах.

### Пример простой XML-разметки

```xml
<system>
  <instruction>Подготовь краткое резюме текста.</instruction>
  <content>{input_text}</content>
</system>
```

## 3.4 Декларативный дизайн и разделение ответственности  

Храните промпты и конфигурации отдельно от бизнес-логики или кода приложения.  
- Определяйте *что* представляет промпт и *как* он параметризован, не вкладывая операционную логику в текст промпта.  
- Это повышает удобство сопровождения, повторное использование и позволяет экспертам по предметной области независимо ревьюить и обновлять промпты без вмешательства инженеров.

Практический пример, иллюстрирующий принцип декларативного дизайна и разделения ответственности

### Шаблон промпта (хранится отдельно от кода)

```text
Здравствуйте, {user_name}!

Вы запросили информацию по теме: "{topic}".

Пожалуйста, уточните, если нужна дополнительная информация.
```

### Код приложения (бизнес-логика)

```python
def generate_prompt(user_name, topic):
    # Загружает шаблон из файла или БД
    template = load_prompt_template("user_info_request.txt")

    # Подставляет конкретные параметры
    prompt = template.format(user_name=user_name, topic=topic)

    return prompt
```

- Промпт полностью описывает *что* показывать, без операционной логики.  
- Коды приложения отвечает за *как* подставлять параметры, запрашивать данные и обрабатывать ответы.  
- Благодаря разделению:  
  - Нельзя случайно изменить логику промпта, работая с кодом.  
  - Эксперты по предмету могут менять тексты промптов, не трогая программистов.  
  - Упрощается сопровождение и масштабирование.

## 3.5 Безопасность

Никогда не встраивайте чувствительные или секретные данные напрямую в промпты. 

Практикуйте: 
- защищённые внешние системы и техники генерации с доступом к внешним данным (retrieval-augmented generation) для динамической подстановки конфиденциального контекста во время выполнения,
- хранение конфиденциальных данных в безопасных хранилищах (vault, менеджеры секретов);
- использование переменных окружения вместо захардкоженных значений;
- ограничение логирования чувствительной информации и мониторинг возможных утечек.

Это минимизирует риски раскрытия секретов в рабочих данных, логах или исходных файлах промптов.

## 3.6 Вложенные промпты или reusable blocks

Модульно стройте промпты из повторно используемых блоков:
- избегайте монолитных длинных промптов для упрощения обновлений, тестирования и переиспользования.

> DRY - Don't Repeat Yourself

```
[System prompt] && [User prompt] → [Модуль 1: анализ запроса] → [Модуль 2: поиск контекста] → [Модуль 3: генерация ответа] → [Модуль 4: форматирование вывода]
```
